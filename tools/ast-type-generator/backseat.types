{
#include "../error_codes.hpp"
#include "../lexer.hpp"
#include "../utils.hpp"
#include <cassert>
#include <fmt/format.h>
#include <memory>
#include <tl/expected.hpp>
#include <tl/optional.hpp>
#include <vector>
}

type Name {
    std::vector<Token> tokens;

    [[nodiscard]] std::string to_string() const {
        auto result = std::string{};
        for (const auto& token : tokens) {
            result = fmt::format("{}{}", result, token.location.ascii_lexeme());
        }
    }
}

type ReturnType {
    Token tilde_arrow;
    Name type;
}

Statement(
    function to_string {std::string}
) =
    ImportStatement(
        import_token {Token}
        module_name by_move { Name }
        semicolon_token{ Token }

        implement to_string {
            return fmt::format("import {};", module_name().to_string());
        }
    )
    | Block(
        left_curly_brace { Token }
        statements by_move { std::vector<std::unique_ptr<Statement>> }
        right_curly_brace { Token }

        implement to_string {
            auto result = std::string{ "{\n" };
            for (const auto& statement : statements()) {
                result += fmt::format("{}\n", statement->to_string());
            }
            return result + "}\n";
        }
    )
    | FunctionDefinition(
        function_keyword {Token}
        identifier {Token}
        left_parenthesis {Token}
        // todo: parameter list
        right_parenthesis {Token}
        return_type by_move {tl::optional<ReturnType>}
        body by_move {Block}

        implement to_string {
            return "todo";
        }
    )

Expression() =
    BinaryOperator(
        lhs by_move { std::unique_ptr<Expression> }
        operator_token { Token }
        rhs by_move { std::unique_ptr<Expression> }
    )
    | UnaryOperator(
        operator_token { Token }
        sub_expression by_move { std::unique_ptr<Expression> }
    )
